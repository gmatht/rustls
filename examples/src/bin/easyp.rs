//! EasyPeas - On-demand HTTPS server with ACME certificate management
//!
//! This example demonstrates a complete on-demand HTTPS server that:
//! - Accepts HTTPS connections using rustls Acceptor
//! - Validates that domains resolve to authorized IP addresses
//! - Dynamically fetches ACME certificates from Let's Encrypt
//! - Caches certificates for performance
//! - Handles both HTTP-01 and DNS-01 challenges
//!
//! Usage:
//!   cargo run --example easyp --features acme -- --help

use std::collections::{HashMap, BTreeMap};
use std::io::{Read, Write};
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr, TcpListener, TcpStream};
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use std::time::Duration;

use clap::Parser;
use rustls::server::{Acceptor, ResolvesServerCert};
use rustls::{ServerConfig, ServerConnection};

#[cfg(feature = "acme")]
use rustls::server::acme::{AcmeClient, OnDemandCertResolver, DnsValidator};
use rustls::server::acme::types::{AcmeConfig, ChallengeType};

// Import our secure file server module
#[path = "../modules/secure_file_server_module.rs"]
mod secure_file_server_module;
use secure_file_server_module::{SecureFileServer, SecurityConfig};

// Extension system - auto-generated by build.rs
#[cfg(feature = "extensions")]
include!(concat!(env!("OUT_DIR"), "/generated_extensions.rs"));

// Always define ExtensionRegistry - either from generated code or as placeholder
#[cfg(not(feature = "extensions"))]
#[derive(Clone)]
struct ExtensionRegistry;

#[cfg(not(feature = "extensions"))]
impl ExtensionRegistry {
    fn new() -> Self {
        Self
    }
    
    fn process_html(&self, html: &str, _url: &str) -> String {
        html.to_string()
    }
    
    fn is_valid_admin_key(&self, _key: &str) -> bool {
        false
    }
    
    async fn process_admin_request(&self, _path: &str, _query: &str, _body: &str, _headers: &std::collections::HashMap<String, String>) -> Result<String, Box<dyn std::error::Error>> {
        Ok(r#"{"error": "Admin features not available"}"#.to_string())
    }
}

/// EasyPeas - On-demand HTTPS server with ACME certificate management
#[derive(Parser, Clone)]
#[command(name = "easyp")]
#[command(about = "EasyPeas - On-demand HTTPS server with ACME certificate management")]
#[command(version)]
struct Args {
    /// Domains to serve (e.g., example.com, *.example.com)
    domains: Vec<String>,
    
    /// HTTP port (default: 80)
    #[arg(long, default_value = "80")]
    http_port: u16,
    
    /// HTTPS port (default: 443)
    #[arg(long, default_value = "443")]
    https_port: u16,
    
    /// Email for ACME certificate registration (defaults to webmaster@domain for each domain)
    #[arg(long)]
    email: Option<String>,
    
    /// Use Let's Encrypt staging environment
    #[arg(long)]
    staging: bool,
    
    /// Add 9000 to default port numbers (HTTP: 9080, HTTPS: 9443)
    #[arg(long)]
    over_9000: bool,
    
    /// Test client binary to run when server is ready
    #[arg(long)]
    test_client: Option<String>,
    
    /// Test root directory for integration tests
    #[arg(long, default_value = "test_root")]
    test_root: String,
    
    /// Document root directory (default: /var/www/html)
    #[arg(long, default_value = "/var/www/html")]
    root: String,
    
    /// Allowed IP addresses for on-demand certificate requests (comma-separated). If not specified, will auto-detect server IPs
    #[arg(long)]
    allowed_ips: Option<String>,
    
    /// Cache directory for ACME certificates (default: /var/lib/easypeas/certs)
    #[arg(long, default_value = "/var/lib/easypeas/certs")]
    cache_dir: String,

    /// Enable verbose logging
    #[arg(short, long)]
    verbose: bool,

    /// Test mode (use self-signed certificates)
    #[arg(long)]
    test_mode: bool,

    /// Bogus domain to use for ACME requests (workaround for rate limits)
    #[arg(long)]
    bogus_domain: Option<String>,

    // Legacy compatibility arguments
    /// Port to listen on (legacy, use --https-port instead)
    #[arg(short, long, default_value = "443")]
    port: u16,

    /// ACME directory URL (legacy, use --staging instead)



    #[arg(long, default_value = "https://acme-v02.api.letsencrypt.org/directory")]
    acme_directory: String,

    /// Email address for ACME account (legacy, use --email instead)
    #[arg(long)]
    acme_email: Option<String>,

    /// Challenge type (http01 or dns01)
    #[arg(long, default_value = "http01")]
    challenge_type: String,
}


/// On-demand HTTPS server
struct OnDemandHttpsServer {
    http_listener: TcpListener,  // Port 80 for ACME challenges
    https_listener: TcpListener, // Port 443 for HTTPS traffic
    cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
    args: Args,
    http_challenges: Arc<Mutex<BTreeMap<String, String>>>, // token -> key_authorization
    acme_client: Option<Arc<AcmeClient>>, // Added for challenge storage
    allowed_ips: Vec<IpAddr>, // Store allowed IPs for display
    extension_registry: ExtensionRegistry, // Extension system
    secure_file_server: SecureFileServer, // Secure file serving with security features
}

impl OnDemandHttpsServer {
    /// Create a new on-demand HTTPS server
    fn new(args: Args) -> Result<Self, Box<dyn std::error::Error>> {
        // Apply --over-9000 option to port numbers
        let http_port = if args.over_9000 {
            args.http_port + 9000
        } else {
            args.http_port
        };
        
        let https_port = if args.over_9000 {
            args.https_port + 9000
        } else {
            args.https_port
        };

        // Use legacy --port argument if provided (overrides --https-port)
        let final_https_port = if args.port != 443 || args.over_9000 {
            args.port
        } else {
            https_port
        };

        // Create HTTP listener on specified port for ACME challenges
        let http_listener = TcpListener::bind(format!("0.0.0.0:{}", http_port))?;
        http_listener.set_nonblocking(true)?;
        
        // Create HTTPS listener on specified port for HTTPS traffic
        let https_listener = TcpListener::bind(format!("0.0.0.0:{}", final_https_port))?;
        https_listener.set_nonblocking(true)?;

        // Look up www-data UID/GID dynamically
        let (www_data_uid, www_data_gid) = get_www_data_uid_gid()?;
        
        // Create secure file server with security features
        let secure_file_server = SecureFileServer::new(SecurityConfig {
            document_root: PathBuf::from(&args.root),
            follow_symlinks: false, // Security: don't follow symlinks by default
            max_file_size: 10 * 1024 * 1024, // 10MB max file size
            allowed_extensions: vec![
                // Web files
                "html".to_string(), "htm".to_string(), "css".to_string(),
                "js".to_string(), "json".to_string(),
                // Images
                "jpg".to_string(), "jpeg".to_string(), "png".to_string(),
                "gif".to_string(), "svg".to_string(), "webp".to_string(),
                "ico".to_string(),
                // WebAssembly
                "wasm".to_string(),
                // Documents
                "txt".to_string(), "pdf".to_string(),
                // Archives
                "zip".to_string(), "tar".to_string(), "gz".to_string(),
            ],
            blocked_extensions: vec![
                // Dangerous executables
                "exe".to_string(), "bat".to_string(), "cmd".to_string(),
                "com".to_string(), "pif".to_string(), "scr".to_string(),
                "vbs".to_string(), "jar".to_string(), "sh".to_string(),
                // System files
                "htaccess".to_string(), "htpasswd".to_string(),
            ],
            drop_to_uid: Some(www_data_uid),
            drop_to_gid: Some(www_data_gid),
        });

               // Parse allowed IP addresses or auto-detect
               let allowed_ips = if let Some(ips_str) = &args.allowed_ips {
                   parse_allowed_ips(ips_str)?
               } else {
                   println!("[{}] No allowed IPs specified, auto-detecting server IPs...", 
                 std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs());
                   detect_server_ips().unwrap_or_else(|e| {
                       println!("Warning: Could not detect server IPs ({}), using localhost fallback", e);
                       vec![IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1))]
                   })
               };

               // Create certificate resolver with real ACME integration
               #[cfg(feature = "acme")]
               let (cert_resolver, acme_client) = if args.test_mode {
                   // In test mode, use staging ACME servers for real certificates
                   let directory_url = "https://acme-staging-v02.api.letsencrypt.org/directory".to_string();
                   
                   // Determine email (prefer new --email over legacy --acme-email)
                   let email = args.email.clone()
                       .or(args.acme_email.clone())
                       .unwrap_or_default();

                   // Determine cache directory (always use the specified cache directory)
                   let cache_dir = Some(args.cache_dir.clone());

                   let acme_config = AcmeConfig {
                       directory_url,
                       email,
                       allowed_ips: allowed_ips.clone(),
                       cache_dir,
                       renewal_threshold_days: 30,
                       challenge_type: ChallengeType::Http01,
                       is_staging: true, // Always staging in test mode
                       bogus_domain: args.bogus_domain.clone(),
                   };

                   let acme_client = AcmeClient::new(acme_config);
                   let acme_client = Arc::new(acme_client);
                   let dns_validator = Arc::new(DnsValidator::new(allowed_ips.clone())?);

                   let cert_resolver = Arc::new(OnDemandCertResolver::new(
                       acme_client.clone(),
                       dns_validator,
                       None, // No fallback resolver
                       1000, // Max cache size
                       Duration::from_secs(30 * 24 * 60 * 60), // 30 days renewal threshold
                   )?);

                   (cert_resolver as Arc<dyn ResolvesServerCert + Send + Sync>, Some(acme_client))
               } else {
                   // Determine ACME directory URL
                   let directory_url = if args.staging {
                       "https://acme-staging-v02.api.letsencrypt.org/directory".to_string()
                   } else {
                       args.acme_directory.clone()
                   };

                   // Determine email (prefer new --email over legacy --acme-email)
                   // If no email is provided, the ACME client will generate webmaster@domain for each domain
                   let email = args.email.clone()
                       .or(args.acme_email.clone())
                       .unwrap_or_default();

                   // Determine cache directory (always use the specified cache directory)
                   let cache_dir = Some(args.cache_dir.clone());

                   let acme_config = AcmeConfig {
                       directory_url,
                       email,
                       allowed_ips: allowed_ips.clone(),
                       cache_dir,
                       renewal_threshold_days: 30,
                       challenge_type: ChallengeType::Http01,
                       is_staging: args.staging || args.acme_directory.contains("staging") || args.acme_directory.contains("stg"),
                       bogus_domain: args.bogus_domain.clone(),
                   };

                   let acme_client = AcmeClient::new(acme_config);

                   // Note: ACME account will be initialized per-domain when certificates are requested

                   let acme_client = Arc::new(acme_client);
                   let dns_validator = Arc::new(DnsValidator::new(allowed_ips.clone())?);

                   let cert_resolver = Arc::new(OnDemandCertResolver::new(
                       acme_client.clone(),
                       dns_validator,
                       None, // No fallback resolver
                       1000, // Max cache size
                       Duration::from_secs(30 * 24 * 60 * 60), // 30 days renewal threshold
                   )?);

                   (cert_resolver as Arc<dyn ResolvesServerCert + Send + Sync>, Some(acme_client))
               };

               #[cfg(not(feature = "acme"))]
               let (cert_resolver, acme_client) = {
                   // Fallback to test resolver if ACME feature not enabled
                   (Arc::new(TestCertResolver::new(allowed_ips)?), None)
               };

               // Ensure certificate cache directory has proper ownership before dropping privileges
               if let Err(e) = ensure_cert_cache_permissions(&args.cache_dir, www_data_uid, www_data_gid) {
                   println!("Warning: Failed to set certificate cache permissions: {}", e);
                   // Continue anyway - this is not a fatal error
               }
               
               // Ensure /tmp/acme_certs directory exists and is owned by www-data (acme-lib requirement)
               if let Err(e) = ensure_tmp_acme_permissions(www_data_uid, www_data_gid) {
                   println!("Warning: Failed to set /tmp/acme_certs permissions: {}", e);
                   // Continue anyway - this is not a fatal error
               }
               
               // Ensure ACME cache directory is properly configured and accessible
               println!("ACME cache directory: {}", args.cache_dir);
               if let Err(e) = ensure_acme_cache_directory(&args.cache_dir, www_data_uid, www_data_gid) {
                   println!("Error: Failed to set up ACME cache directory: {}", e);
                   return Err(format!("ACME cache directory setup failed: {}", e).into());
               }
               
               // Initialize domain request logger
               let mut domain_logger = DomainRequestLogger::new(&args.cache_dir)
                   .unwrap_or_else(|e| {
                       println!("Warning: Failed to initialize domain logger: {}", e);
                       // Create a dummy logger that does nothing
                       DomainRequestLogger {
                           log_file: std::path::PathBuf::new(),
                           requests: Vec::new(),
                       }
                   });
               
               // Drop privileges to unprivileged user after binding to privileged ports
               if let Err(e) = secure_file_server.drop_privileges() {
                   println!("Warning: Failed to drop privileges: {}", e);
                   // Continue anyway - this is not a fatal error
               } else {
                   // Verify that privileges were dropped successfully
                   match std::process::Command::new("whoami").output() {
                       Ok(output) => {
                           if output.status.success() {
                               let username = String::from_utf8_lossy(&output.stdout).trim().to_string();
                               println!("Server now running as user: {}", username);
                           } else {
                               println!("Warning: Could not determine current user after privilege drop");
                           }
                       }
                       Err(_) => {
                           println!("Warning: Could not determine current user after privilege drop");
                       }
                   }
               }


               Ok(Self {
                   http_listener,
                   https_listener,
                   cert_resolver,
                   args,
                   http_challenges: Arc::new(Mutex::new(BTreeMap::new())),
                   acme_client,
                   allowed_ips,
                   extension_registry: ExtensionRegistry::new(),
                   secure_file_server,
               })
    }

    /// Run the server
    fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Calculate actual ports (including --over-9000 effect)
        let http_port = if self.args.over_9000 {
            self.args.http_port + 9000
        } else {
            self.args.http_port
        };
        
        let https_port = if self.args.over_9000 {
            self.args.https_port + 9000
        } else {
            self.args.https_port
        };

        let final_https_port = if self.args.port != 443 || self.args.over_9000 {
            self.args.port
        } else {
            https_port
        };

        println!("Starting EasyPeas on-demand HTTPS server");
        println!("HTTP listener on port {} (for ACME challenges)", http_port);
        println!("HTTPS listener on port {} (for HTTPS traffic)", final_https_port);
        println!("Allowed IPs: {:?}", self.allowed_ips);
        println!("ACME Directory: {}", if self.args.staging { "https://acme-staging-v02.api.letsencrypt.org/directory" } else { &self.args.acme_directory });
        println!("Challenge Type: {}", self.args.challenge_type);
        println!("Test Mode: {}", self.args.test_mode);
        if !self.args.domains.is_empty() {
            println!("Domains: {:?}", self.args.domains);
        }
        if let Some(ref email) = self.args.email.clone().or(self.args.acme_email.clone()) {
            println!("Email: {}", email);
        }
        println!("Document Root: {}", self.args.root);
        println!("Cache Directory: {}", self.args.cache_dir);

        // Run test client if specified
        if let Some(ref test_client) = self.args.test_client {
            let test_client = test_client.clone();
            println!("Running test client: {}", test_client);
            std::thread::spawn(move || {
                let output = std::process::Command::new(&test_client)
                    .output()
                    .expect("Failed to execute test client");
                println!("Test client output: {}", String::from_utf8_lossy(&output.stdout));
                if !output.stderr.is_empty() {
                    eprintln!("Test client stderr: {}", String::from_utf8_lossy(&output.stderr));
                }
            });
        }

        let mut connections: Vec<ServerConnection> = Vec::new();

        loop {
            // Accept HTTP connections (port 80) for ACME challenges
            match self.http_listener.accept() {
                Ok((stream, addr)) => {
                    println!("New HTTP connection from {} (ACME challenge)", addr);
                    
                    // Handle HTTP connection for ACME challenges and file serving
                    let acme_client = self.acme_client.clone();
                    let http_challenges = self.http_challenges.clone();
                    let secure_file_server = self.secure_file_server.clone();

                    std::thread::spawn(move || {
                        if let Err(e) = Self::handle_http_connection(stream, acme_client, http_challenges, secure_file_server) {
                            eprintln!("HTTP connection error: {}", e);
                        }
                    });
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No connection available, continue
                }
                Err(e) => {
                    eprintln!("HTTP accept error: {}", e);
                }
            }

            // Accept HTTPS connections (port 443) for HTTPS traffic
            match self.https_listener.accept() {
                Ok((stream, addr)) => {
                    println!("New HTTPS connection from {}", addr);
                    
                    // Handle HTTPS connection
                    let cert_resolver = self.cert_resolver.clone();
                    let args = self.args.clone();
                    let acme_client = self.acme_client.clone();
                    let http_challenges = self.http_challenges.clone();
                    let extension_registry = self.extension_registry.clone();
                    let secure_file_server = self.secure_file_server.clone();

                           std::thread::spawn(move || {
                        if let Err(e) = Self::handle_connection_static(stream, cert_resolver, args, acme_client, http_challenges, extension_registry, secure_file_server) {
                                   eprintln!("HTTPS connection error: {}", e);
                               }
                           });
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No connection available, continue
                }
                Err(e) => {
                    eprintln!("HTTPS accept error: {}", e);
                }
            }

            // Process existing connections
            connections.retain(|conn| {
                // In a real implementation, you'd process the connection here
                // For this example, we just remove completed connections
                false
            });

            // Small delay to prevent busy waiting
            std::thread::sleep(Duration::from_millis(10));
        }
    }

    /// Handle HTTP connection (port 80) for ACME challenges and file serving
    fn handle_http_connection(
        mut stream: TcpStream,
        acme_client: Option<Arc<AcmeClient>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: SecureFileServer,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Read HTTP request
        let mut buffer = [0; 4096];
        let mut total_read = 0;

        // Read data in a loop to handle partial reads
        loop {
            match stream.read(&mut buffer[total_read..]) {
                Ok(0) => break, // Connection closed
                Ok(n) => {
                    total_read += n;
                    if total_read >= buffer.len() {
                        break; // Buffer full
                    }
                    // Check if we have a complete HTTP request
                    if let Ok(request_str) = std::str::from_utf8(&buffer[..total_read]) {
                        if request_str.contains("\r\n\r\n") {
                            break; // Complete HTTP request received
                        }
                    }
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No data available, wait a bit
                    std::thread::sleep(std::time::Duration::from_millis(10));
                    continue;
                }
                Err(e) => return Err(e.into()),
            }
        }

        // Parse HTTP request
        let request = String::from_utf8_lossy(&buffer[..total_read]);
        let lines: Vec<&str> = request.lines().collect();

        if let Some(first_line) = lines.first() {
            println!("HTTP Request: {}", first_line);

            // Handle HTTP-01 ACME challenges
            if first_line.starts_with("GET /.well-known/acme-challenge/") {
                return Self::handle_acme_challenge_http(stream, first_line, &acme_client, &http_challenges);
            }
        }

        // Extract the request path from the HTTP request
        let request_path = if let Some(first_line) = lines.first() {
            if let Some(path_start) = first_line.find(' ') {
                if let Some(path_end) = first_line[path_start + 1..].find(' ') {
                    &first_line[path_start + 1..path_start + 1 + path_end]
                } else {
                    "/"
                }
            } else {
                "/"
            }
        } else {
            "/"
        };

        println!("Requested path: {}", request_path);

        // Try to serve the requested file using secure file server
        match secure_file_server.serve_file(request_path) {
            Ok(Some(file_content)) => {
                // Successfully served a file
                match secure_file_server.generate_http_response(request_path, file_content.as_slice()) {
                    Ok(response_headers) => {
                        let mut response = response_headers;
                        response.push_str(&String::from_utf8_lossy(&file_content));

                        stream.write_all(response.as_bytes())?;
                        stream.flush()?;
                    }
                    Err(e) => {
                        println!("Error generating HTTP response: {}", e);
                        let error_response = "HTTP/1.1 500 Internal Server Error\r\n\
                                             Content-Type: text/plain\r\n\
                                             Content-Length: 21\r\n\
                                             Connection: close\r\n\
                                             \r\n\
                                             Internal Server Error";
                        stream.write_all(error_response.as_bytes())?;
                        stream.flush()?;
                    }
                }
            }
            Ok(None) => {
                // File not found - check if this is a root request (index.html missing)
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page
                    let default_page = secure_file_server.generate_default_page("localhost");
                    let response = format!(
                        "HTTP/1.1 200 OK\r\n\
                         Content-Type: text/html; charset=utf-8\r\n\
                         Content-Length: {}\r\n\
                         Connection: close\r\n\
                         \r\n\
                         {}",
                        default_page.len(),
                        default_page
                    );

                    stream.write_all(response.as_bytes())?;
                    stream.flush()?;
                } else {
                    // File not found, send 404 for non-root requests
        let response = "HTTP/1.1 404 Not Found\r\n\
                       Content-Type: text/plain\r\n\
                       Content-Length: 13\r\n\
                       Connection: close\r\n\
                       \r\n\
                       Not Found";
        stream.write_all(response.as_bytes())?;
        stream.flush()?;
                }
            }
            Err(e) => {
                // Security error or other error - check if this is a root request first
                println!("Request denied for {}: {}", request_path, e);
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page even for security errors on root
                    let default_page = secure_file_server.generate_default_page("localhost");
                    let response = format!(
                        "HTTP/1.1 200 OK\r\n\
                         Content-Type: text/html; charset=utf-8\r\n\
                         Content-Length: {}\r\n\
                         Connection: close\r\n\
                         \r\n\
                         {}",
                        default_page.len(),
                        default_page
                    );
                    stream.write_all(response.as_bytes())?;
                    stream.flush()?;
                } else {
                    // Send 404 for non-root requests with security errors
                    let response = "HTTP/1.1 404 Not Found\r\n\
                                   Content-Type: text/plain\r\n\
                                   Content-Length: 13\r\n\
                                   Connection: close\r\n\
                                   \r\n\
                                   Not Found";
                    stream.write_all(response.as_bytes())?;
                    stream.flush()?;
                }
            }
        }

        Ok(())
    }

    /// Handle a single HTTPS connection (static version for threading)
    fn handle_connection_static(
        mut stream: TcpStream,
        cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
        args: Args,
        acme_client: Option<Arc<AcmeClient>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        extension_registry: ExtensionRegistry,
        secure_file_server: SecureFileServer,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut acceptor = Acceptor::default();

        // Read TLS packets until we have a complete ClientHello
        let accepted = loop {
            match acceptor.read_tls(&mut stream) {
                Ok(0) => return Ok(()), // Connection closed
                Ok(_) => {
                    match acceptor.accept() {
                        Ok(Some(accepted)) => break accepted,
                        Ok(None) => continue,
                        Err((e, mut alert)) => {
                            alert.write_all(&mut stream)?;
                            return Err(format!("Error accepting connection: {}", e).into());
                        }
                    }
                }
                Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No data available, continue
                    continue;
                }
                Err(e) => return Err(e.into()),
            }
        };

        // Get the server name from ClientHello
        let server_name = accepted.client_hello().server_name()
            .map(|name| name.as_ref().to_string())
            .unwrap_or_else(|| "unknown".to_string());

        println!("Processing request for domain: {}", server_name);

        // Create server config with our certificate resolver
        let server_config = ServerConfig::builder_with_provider(
            rustls::crypto::aws_lc_rs::default_provider().into()
        )
        .with_no_client_auth()
        .with_cert_resolver(cert_resolver)
        .map_err(|e| format!("Failed to create server config: {}", e))?;

        // Complete the TLS handshake
        let mut conn = match accepted.into_connection(Arc::new(server_config)) {
            Ok(conn) => conn,
            Err((e, mut alert)) => {
                alert.write_all(&mut stream)?;
                return Err(format!("Error completing connection: {}", e).into());
            }
        };

        // Handle the connection
        println!("🔍 About to call process_https_request_static for domain: {}", server_name);
        Self::process_https_request_static(&mut stream, &mut conn, &server_name, &acme_client, &http_challenges, &extension_registry, &secure_file_server)?;
        println!("🔍 process_https_request_static completed for domain: {}", server_name);

        Ok(())
    }

    /// Handle a single HTTPS connection
    fn handle_connection(
        &self,
        mut stream: TcpStream,
        cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
        args: Args,
        acme_client: Option<Arc<AcmeClient>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        extension_registry: ExtensionRegistry,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut acceptor = Acceptor::default();

        // Read TLS packets until we have a complete ClientHello
        let accepted = loop {
            match acceptor.read_tls(&mut stream) {
                Ok(0) => return Ok(()), // Connection closed
                Ok(_) => {
                    match acceptor.accept() {
                        Ok(Some(accepted)) => break accepted,
                        Ok(None) => continue,
                        Err((e, mut alert)) => {
                            alert.write_all(&mut stream)?;
                            return Err(format!("Error accepting connection: {}", e).into());
                        }
                    }
                }
                Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No data available, continue
                    continue;
                }
                Err(e) => return Err(e.into()),
            }
        };

        // Get the server name from ClientHello
        let server_name = accepted.client_hello().server_name()
            .map(|name| name.as_ref().to_string())
            .unwrap_or_else(|| "unknown".to_string());

        println!("Processing request for domain: {}", server_name);

        // Create server config with our certificate resolver
        let server_config = ServerConfig::builder_with_provider(
            rustls::crypto::aws_lc_rs::default_provider().into()
        )
        .with_no_client_auth()
        .with_cert_resolver(cert_resolver)
        .map_err(|e| format!("Failed to create server config: {}", e))?;

        // Complete the TLS handshake
        let mut conn = match accepted.into_connection(Arc::new(server_config)) {
            Ok(conn) => conn,
            Err((e, mut alert)) => {
                alert.write_all(&mut stream)?;
                return Err(format!("Error completing connection: {}", e).into());
            }
        };

        // Handle the connection
        self.process_https_request(&mut stream, &mut conn, &server_name, &acme_client, &http_challenges, &extension_registry)?;

        Ok(())
    }

    /// Process HTTPS request and send response (static version for threading)
    fn process_https_request_static(
        stream: &mut TcpStream,
        conn: &mut ServerConnection,
        server_name: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        extension_registry: &ExtensionRegistry,
        secure_file_server: &SecureFileServer,
    ) -> Result<(), Box<dyn std::error::Error>> {
        println!("🔍 process_https_request_static started for domain: {}", server_name);
        // Complete the handshake
        println!("🔍 About to complete TLS handshake for domain: {}", server_name);
        conn.complete_io(stream)?;
        println!("🔍 TLS handshake completed for domain: {}", server_name);

        // Read HTTP request using the TLS connection
        let mut buffer = [0; 4096];
        let mut total_read = 0;

        println!("🔍 Starting to read HTTP request for domain: {}", server_name);
        
        // Complete any pending TLS I/O before reading
        println!("🔍 Completing pending TLS I/O for domain: {}", server_name);
        conn.complete_io(stream)?;
        println!("🔍 TLS I/O completed for domain: {}", server_name);
        
        // Read data in a loop to handle partial reads
        let mut read_attempts = 0;
        const MAX_READ_ATTEMPTS: usize = 1000; // 10 seconds with 10ms sleep
        
        loop {
            read_attempts += 1;
            if read_attempts > MAX_READ_ATTEMPTS {
                println!("🔍 Timeout waiting for HTTP request from domain: {}", server_name);
                return Err("Timeout waiting for HTTP request".into());
            }
            
            println!("🔍 Attempting to read data for domain: {} (total_read: {}, attempt: {})", server_name, total_read, read_attempts);
            match conn.reader().read(&mut buffer[total_read..]) {
                Ok(0) => {
                    println!("🔍 Connection closed for domain: {}", server_name);
                    break; // Connection closed
                }
                Ok(n) => {
                    println!("🔍 Read {} bytes for domain: {}", n, server_name);
                    total_read += n;
                    if total_read >= buffer.len() {
                        println!("🔍 Buffer full for domain: {}", server_name);
                        break; // Buffer full
                    }
                    // Check if we have a complete HTTP request
                    if let Ok(request_str) = std::str::from_utf8(&buffer[..total_read]) {
                        println!("🔍 Current request data for domain {}: {}", server_name, request_str);
                        if request_str.contains("\r\n\r\n") {
                            println!("🔍 Complete HTTP request received for domain: {}", server_name);
                            break; // Complete HTTP request received
                        }
                    }
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    println!("🔍 WouldBlock error for domain: {}, waiting... (attempt {})", server_name, read_attempts);
                    // No data available, wait a bit
                    std::thread::sleep(std::time::Duration::from_millis(10));
                    continue;
                }
                Err(e) => {
                    println!("🔍 Read error for domain {}: {}", server_name, e);
                    return Err(e.into());
                }
            }
        }

        let n = total_read;

        // Parse HTTP request (simplified)
        let request = String::from_utf8_lossy(&buffer[..n]);
        let lines: Vec<&str> = request.lines().collect();

        if let Some(first_line) = lines.first() {
            println!("HTTP Request: {}", first_line);

                   // Handle HTTP-01 ACME challenges
                   if first_line.starts_with("GET /.well-known/acme-challenge/") {
                       return Self::handle_acme_challenge_static(stream, conn, first_line, acme_client, http_challenges);
                   }
        }

        // Extract the request path from the HTTP request
        let request_path = if let Some(first_line) = lines.first() {
            if let Some(path_start) = first_line.find(' ') {
                if let Some(path_end) = first_line[path_start + 1..].find(' ') {
                    &first_line[path_start + 1..path_start + 1 + path_end]
                } else {
                    "/"
                }
            } else {
                "/"
            }
        } else {
            "/"
        };

        println!("Requested path: {}", request_path);

        // Try to serve the requested file using secure file server
        match secure_file_server.serve_file(request_path) {
            Ok(Some(file_content)) => {
                // Successfully served a file
                match secure_file_server.generate_http_response(request_path, file_content.as_slice()) {
                    Ok(response_headers) => {
                        let mut response = response_headers;
                        response.push_str(&String::from_utf8_lossy(&file_content));

                        conn.writer().write_all(response.as_bytes())?;
                        conn.write_tls(stream)?;
                        conn.complete_io(stream)?;
                    }
                    Err(e) => {
                        println!("Error generating HTTP response: {}", e);
                        Self::send_error_response_static(conn, stream, 500, "Internal Server Error")?;
                    }
                }
            }
            Ok(None) => {
                // File not found - check if this is a root request (index.html missing)
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page
                    let default_page = secure_file_server.generate_default_page(server_name);
                    let response = format!(
                        "HTTP/1.1 200 OK\r\n\
                         Content-Type: text/html; charset=utf-8\r\n\
                         Content-Length: {}\r\n\
                         Connection: close\r\n\
                         \r\n\
                         {}",
                        default_page.len(),
                        default_page
                    );

                    conn.writer().write_all(response.as_bytes())?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                } else {
                    // File not found, send 404 for non-root requests
                    Self::send_error_response_static(conn, stream, 404, "Not Found")?;
                }
            }
            Err(e) => {
                // Security error or other error - check if this is a root request first
                println!("Request denied for {}: {}", request_path, e);
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page even for security errors on root
                    let default_page = secure_file_server.generate_default_page(server_name);
                    let response = format!(
                        "HTTP/1.1 200 OK\r\n\
                         Content-Type: text/html; charset=utf-8\r\n\
                         Content-Length: {}\r\n\
                         Connection: close\r\n\
                         \r\n\
                         {}",
                        default_page.len(),
                        default_page
                    );

                    conn.writer().write_all(response.as_bytes())?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                } else {
                    // Send 404 for non-root requests with security errors
                    Self::send_error_response_static(conn, stream, 404, "Not Found")?;
                }
            }
        }

        Ok(())
    }

    /// Process HTTPS request and send response
    fn process_https_request(
        &self,
        stream: &mut TcpStream,
        conn: &mut ServerConnection,
        server_name: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        extension_registry: &ExtensionRegistry,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Complete the handshake
        conn.complete_io(stream)?;

        // Read HTTP request using the TLS connection
        let mut buffer = [0; 4096];
        let mut total_read = 0;

        // Read data in a loop to handle partial reads
        loop {
            match conn.reader().read(&mut buffer[total_read..]) {
                Ok(0) => break, // Connection closed
                Ok(n) => {
                    total_read += n;
                    if total_read >= buffer.len() {
                        break; // Buffer full
                    }
                    // Check if we have a complete HTTP request
                    if let Ok(request_str) = std::str::from_utf8(&buffer[..total_read]) {
                        if request_str.contains("\r\n\r\n") {
                            break; // Complete HTTP request received
                        }
                    }
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No data available, wait a bit
                    std::thread::sleep(std::time::Duration::from_millis(10));
                    continue;
                }
                Err(e) => return Err(e.into()),
            }
        }
        
        let n = total_read;

        // Parse HTTP request (simplified)
        let request = String::from_utf8_lossy(&buffer[..n]);
        let lines: Vec<&str> = request.lines().collect();

        if let Some(first_line) = lines.first() {
            println!("HTTP Request: {}", first_line);
            
                   // Handle HTTP-01 ACME challenges
                   if first_line.starts_with("GET /.well-known/acme-challenge/") {
                       return Self::handle_acme_challenge(stream, conn, first_line, acme_client, http_challenges);
                   }
        }

        // Try to serve the requested file using secure file server
        let request_path = "/"; // Default to root path
        match self.secure_file_server.serve_file(request_path) {
            Ok(Some(file_content)) => {
                // Successfully served a file
                match self.secure_file_server.generate_http_response(request_path, file_content.as_slice()) {
                    Ok(response_headers) => {
                        let mut response = response_headers;
                        response.push_str(&String::from_utf8_lossy(&file_content));

                        conn.writer().write_all(response.as_bytes())?;
                        conn.write_tls(stream)?;
                        conn.complete_io(stream)?;
                    }
                    Err(e) => {
                        println!("Error generating HTTP response: {}", e);
                        Self::send_error_response(conn, stream, 500, "Internal Server Error")?;
                    }
                }
            }
            Ok(None) => {
                // File not found, send 404
                Self::send_error_response(conn, stream, 404, "Not Found")?;
            }
            Err(e) => {
                // Security error or other error, send 403 or 404 for security
                println!("Request denied for {}: {}", request_path, e);
                Self::send_error_response(conn, stream, 404, "Not Found")?;
            }
        }

        Ok(())
    }

    /// Send an error response (static version for threading)
    fn send_error_response_static(
        conn: &mut ServerConnection,
        stream: &mut TcpStream,
        status_code: u16,
        status_text: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let body = format!(
            "<!DOCTYPE html>\n\
             <html>\n\
             <head>\n\
                 <title>{} {}</title>\n\
                 <style>\n\
                     body {{ font-family: Arial, sans-serif; margin: 40px; text-align: center; }}\n\
                     .error {{ background: #e74c3c; color: white; padding: 20px; border-radius: 5px; display: inline-block; }}\n\
                 </style>\n\
             </head>\n\
             <body>\n\
                 <div class=\"error\">\n\
                     <h1>{} {}</h1>\n\
                     <p>EasyPeas HTTPS Server</p>\n\
                 </div>\n\
             </body>\n\
             </html>",
            status_code, status_text, status_code, status_text
        );

        let response = format!(
            "HTTP/1.1 {} {}\r\n\
             Content-Type: text/html; charset=utf-8\r\n\
             Content-Length: {}\r\n\
             Connection: close\r\n\
             \r\n\
             {}",
            status_code, status_text, body.len(), body
        );

        conn.writer().write_all(response.as_bytes())?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Send an error response
    fn send_error_response(
        conn: &mut ServerConnection,
        stream: &mut TcpStream,
        status_code: u16,
        status_text: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let body = format!(
            "<!DOCTYPE html>\n\
             <html>\n\
             <head>\n\
                 <title>{} {}</title>\n\
                 <style>\n\
                     body {{ font-family: Arial, sans-serif; margin: 40px; text-align: center; }}\n\
                     .error {{ background: #e74c3c; color: white; padding: 20px; border-radius: 5px; display: inline-block; }}\n\
                 </style>\n\
             </head>\n\
             <body>\n\
                 <div class=\"error\">\n\
                     <h1>{} {}</h1>\n\
                     <p>EasyPeas HTTPS Server</p>\n\
                 </div>\n\
             </body>\n\
             </html>",
            status_code, status_text, status_code, status_text
        );

        let response = format!(
            "HTTP/1.1 {} {}\r\n\
             Content-Type: text/html; charset=utf-8\r\n\
             Content-Length: {}\r\n\
             Connection: close\r\n\
             \r\n\
             {}",
            status_code, status_text, body.len(), body
        );

        conn.writer().write_all(response.as_bytes())?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Handle HTTP-01 ACME challenge over HTTP (port 80)
    fn handle_acme_challenge_http(
        mut stream: TcpStream,
        request_line: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Extract token from request path
        // GET /.well-known/acme-challenge/{token} HTTP/1.1
        let path = request_line.split_whitespace().nth(1).unwrap_or("");
        let token = path.strip_prefix("/.well-known/acme-challenge/").unwrap_or("");

        println!("ACME HTTP-01 challenge request for token: {}", token);

        // Look up the key authorization for this token
        let key_authorization = Self::get_challenge_response_from_params(acme_client, http_challenges, token);

        let response = if let Some(key_auth) = key_authorization {
            println!("Serving challenge response for token: {}", token);
            format!(
                "HTTP/1.1 200 OK\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: {}\r\n\
                 Cache-Control: no-cache\r\n\
                 Connection: close\r\n\
                 \r\n\
                 {}",
                key_auth.len(),
                key_auth
            )
        } else {
            println!("Challenge token not found: {}", token);
            format!(
                "HTTP/1.1 404 Not Found\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: 13\r\n\
                 Connection: close\r\n\
                 \r\n\
                 Not Found"
            )
        };

        stream.write_all(response.as_bytes())?;
        stream.flush()?;

        Ok(())
    }

    /// Handle HTTP-01 ACME challenge over HTTPS (port 443) - static version for threading
    fn handle_acme_challenge_static(
        stream: &mut TcpStream,
        conn: &mut ServerConnection,
        request_line: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Extract token from request path
        // GET /.well-known/acme-challenge/{token} HTTP/1.1
        let path = request_line.split_whitespace().nth(1).unwrap_or("");
        let token = path.strip_prefix("/.well-known/acme-challenge/").unwrap_or("");

        println!("ACME HTTP-01 challenge request for token: {}", token);

        // Look up the key authorization for this token
        let key_authorization = Self::get_challenge_response_from_params_static(acme_client, http_challenges, token);

        let response = if let Some(key_auth) = key_authorization {
            println!("Serving challenge response for token: {}", token);
            format!(
                "HTTP/1.1 200 OK\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: {}\r\n\
                 Cache-Control: no-cache\r\n\
                 Connection: close\r\n\
                 \r\n\
                 {}",
                key_auth.len(),
                key_auth
            )
        } else {
            println!("Challenge token not found: {}", token);
            format!(
                "HTTP/1.1 404 Not Found\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: 13\r\n\
                 Connection: close\r\n\
                 \r\n\
                 Not Found"
            )
        };

        conn.writer().write_all(response.as_bytes())?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Handle HTTP-01 ACME challenge over HTTPS (port 443)
    fn handle_acme_challenge(
        stream: &mut TcpStream,
        conn: &mut ServerConnection,
        request_line: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Extract token from request path
        // GET /.well-known/acme-challenge/{token} HTTP/1.1
        let path = request_line.split_whitespace().nth(1).unwrap_or("");
        let token = path.strip_prefix("/.well-known/acme-challenge/").unwrap_or("");

        println!("ACME HTTP-01 challenge request for token: {}", token);

        // Look up the key authorization for this token
        let key_authorization = Self::get_challenge_response_from_params(acme_client, http_challenges, token);

        let response = if let Some(key_auth) = key_authorization {
            println!("Serving challenge response for token: {}", token);
            format!(
                "HTTP/1.1 200 OK\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: {}\r\n\
                 Cache-Control: no-cache\r\n\
                 Connection: close\r\n\
                 \r\n\
                 {}",
                key_auth.len(),
                key_auth
            )
        } else {
            println!("Challenge token not found: {}", token);
            format!(
                "HTTP/1.1 404 Not Found\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: 13\r\n\
                 Connection: close\r\n\
                 \r\n\
                 Not Found"
            )
        };

        conn.writer().write_all(response.as_bytes())?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Get challenge response for a token from ACME client
    fn get_challenge_response(&self, token: &str) -> Option<String> {
        // Try to get from ACME client if available
        if let Some(acme_client) = &self.acme_client {
            let rt = tokio::runtime::Runtime::new().unwrap();
            if let Some(response) = rt.block_on(acme_client.get_challenge_response(token)) {
                return Some(response);
            }
        }
        
        // Fallback to local storage
        if let Ok(challenges) = self.http_challenges.lock() {
            if let Some(response) = challenges.get(token) {
                return Some(response.clone());
            }
        }
        
        // Last resort: placeholder response
        if !token.is_empty() {
            Some(format!("challenge-response-for-{}", token))
        } else {
            None
        }
    }

    /// Get challenge response for a token from parameters (static method)
    fn get_challenge_response_from_params_static(
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        token: &str,
    ) -> Option<String> {
        // Try to get from ACME client if available
        if let Some(acme_client) = acme_client {
            let rt = tokio::runtime::Runtime::new().unwrap();
            if let Some(response) = rt.block_on(acme_client.get_challenge_response(token)) {
                return Some(response);
            }
        }
        
        // Fallback to local storage
        if let Ok(challenges) = http_challenges.lock() {
            if let Some(response) = challenges.get(token) {
                return Some(response.clone());
            }
        }
        
        // Last resort: placeholder response
        if !token.is_empty() {
            Some(format!("challenge-response-for-{}", token))
        } else {
            None
        }
    }

    /// Get challenge response for a token from parameters (static method)
    fn get_challenge_response_from_params(
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        token: &str,
    ) -> Option<String> {
        // Try to get from ACME client if available
        if let Some(acme_client) = acme_client {
            let rt = tokio::runtime::Runtime::new().unwrap();
            if let Some(response) = rt.block_on(acme_client.get_challenge_response(token)) {
                return Some(response);
            }
        }
        
        // Fallback to local storage
        if let Ok(challenges) = http_challenges.lock() {
            if let Some(response) = challenges.get(token) {
                return Some(response.clone());
            }
        }
        
        // Last resort: placeholder response
        if !token.is_empty() {
            Some(format!("challenge-response-for-{}", token))
        } else {
            None
        }
    }
}


/// Ensure /tmp/acme_certs directory exists and is owned by www-data (acme-lib requirement)
fn ensure_tmp_acme_permissions(uid: u32, gid: u32) -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;
    
    let tmp_acme_dir = "/tmp/acme_certs";
    
    // Create the directory if it doesn't exist
    let output = Command::new("mkdir")
        .args(&["-p", tmp_acme_dir])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to create /tmp/acme_certs directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }
    
    // Set ownership to www-data
    let output = Command::new("chown")
        .args(&["-R", &format!("{}:{}", uid, gid), tmp_acme_dir])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to set ownership of /tmp/acme_certs directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }
    
    // Set permissions to 755
    let output = Command::new("chmod")
        .args(&["-R", "755", tmp_acme_dir])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to set permissions of /tmp/acme_certs directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }
    
    println!("Certificate cache directory permissions set: {} (owner: {})", tmp_acme_dir, uid);
    Ok(())
}

/// Domain request log entry
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
struct DomainRequestLog {
    domain: String,
    timestamp: std::time::SystemTime,
    is_production: bool,
    bogus_domain: Option<String>,
}

/// Domain request logger
struct DomainRequestLogger {
    log_file: std::path::PathBuf,
    requests: Vec<DomainRequestLog>,
}

impl DomainRequestLogger {
    fn new(cache_dir: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let log_file = std::path::PathBuf::from(cache_dir).join("domain_requests.json");
        let mut logger = Self {
            log_file,
            requests: Vec::new(),
        };
        logger.load()?;
        Ok(logger)
    }

    fn load(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        if self.log_file.exists() {
            let content = std::fs::read_to_string(&self.log_file)?;
            self.requests = serde_json::from_str(&content).unwrap_or_default();
        }
        Ok(())
    }

    fn save(&self) -> Result<(), Box<dyn std::error::Error>> {
        let content = serde_json::to_string_pretty(&self.requests)?;
        std::fs::write(&self.log_file, content)?;
        Ok(())
    }

    fn log_request(&mut self, domain: &str, is_production: bool, bogus_domain: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
        let entry = DomainRequestLog {
            domain: domain.to_string(),
            timestamp: std::time::SystemTime::now(),
            is_production,
            bogus_domain: bogus_domain.map(|s| s.to_string()),
        };
        
        // Check if this is a new production certificate for a previously logged domain
        if is_production {
            for existing in &self.requests {
                if existing.domain == domain && !existing.is_production {
                    println!("⚠️  WARNING: PRODUCTION CERTIFICATE REQUESTED FOR PREVIOUSLY LOGGED DOMAIN!");
                    println!("   Domain: {}", domain);
                    println!("   Previous request was non-production at: {:?}", existing.timestamp);
                    println!("   This may indicate rate limit workaround usage!");
                    println!("   ⚠️  WARNING: PRODUCTION CERTIFICATE REQUESTED FOR PREVIOUSLY LOGGED DOMAIN! ⚠️");
                }
            }
        }
        
        self.requests.push(entry);
        self.save()?;
        Ok(())
    }

    fn has_been_requested(&self, domain: &str) -> bool {
        self.requests.iter().any(|r| r.domain == domain)
    }
}


/// Ensure certificate cache directory has proper ownership for www-data
fn ensure_cert_cache_permissions(cache_dir: &str, uid: u32, gid: u32) -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;
    
    // Create the directory if it doesn't exist
    let output = Command::new("mkdir")
        .args(&["-p", cache_dir])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to create certificate cache directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }
    
    // Create subdirectories that ACME client needs (based on environment)
    let staging_dir = format!("{}/staging", cache_dir);
    let production_dir = format!("{}/production", cache_dir);
    
    for dir in [&staging_dir, &production_dir] {
        let output = Command::new("mkdir")
            .args(&["-p", dir])
            .output()?;
        
        if !output.status.success() {
            return Err(format!("Failed to create certificate directory {}: {}", dir, String::from_utf8_lossy(&output.stderr)).into());
        }
    }
    
    // Set ownership to www-data recursively
    let output = Command::new("chown")
        .args(&["-R", &format!("{}:{}", uid, gid), cache_dir])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to set ownership of certificate cache directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }
    
    // Set permissions to 755 recursively
    let output = Command::new("chmod")
        .args(&["-R", "755", cache_dir])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to set permissions of certificate cache directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }
    
    println!("Certificate cache directory permissions set: {} (owner: {})", cache_dir, uid);
    Ok(())
}

/// Ensure ACME cache directory is properly set up with www-data permissions
fn ensure_acme_cache_directory(cache_dir: &str, uid: u32, gid: u32) -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;
    
    // Create the main cache directory
    std::fs::create_dir_all(cache_dir)?;
    
    // Create the acme_lib subdirectory
    let acme_lib_dir = format!("{}/acme_lib", cache_dir);
    std::fs::create_dir_all(&acme_lib_dir)?;
    
    // Set ownership to www-data for both directories
    let output = Command::new("chown")
        .args(&["-R", &format!("{}:{}", uid, gid), cache_dir])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to set ownership of ACME cache directory '{}': {}", cache_dir, String::from_utf8_lossy(&output.stderr)).into());
    }
    
    // Set permissions to 755 for both directories
    let output = Command::new("chmod")
        .args(&["-R", "755", cache_dir])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to set permissions of ACME cache directory '{}': {}", cache_dir, String::from_utf8_lossy(&output.stderr)).into());
    }
    
    println!("ACME cache directory permissions set: {} (owner: {})", cache_dir, uid);
    println!("ACME lib directory created: {}", acme_lib_dir);
    Ok(())
}

/// Ensure www-data user exists, create if necessary
fn ensure_www_data_user() -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;
    
    // Check if www-data user exists
    let check_output = Command::new("id")
        .args(&["-u", "www-data"])
        .output()?;
    
    if check_output.status.success() {
        // User exists, nothing to do
        return Ok(());
    }
    
    println!("www-data user not found, creating...");
    
    // Create www-data group first
    let group_output = Command::new("groupadd")
        .args(&["www-data"])
        .output()?;
    
    if !group_output.status.success() {
        let stderr = String::from_utf8_lossy(&group_output.stderr);
        if !stderr.contains("already exists") {
            return Err(format!("Failed to create www-data group: {}", stderr).into());
        }
    }
    
    // Create www-data user
    let user_output = Command::new("useradd")
        .args(&["-r", "-g", "www-data", "-s", "/bin/false", "-d", "/var/www", "www-data"])
        .output()?;
    
    if !user_output.status.success() {
        let stderr = String::from_utf8_lossy(&user_output.stderr);
        if !stderr.contains("already exists") {
            return Err(format!("Failed to create www-data user: {}", stderr).into());
        }
    }
    
    println!("✅ www-data user created successfully");
    Ok(())
}

/// Look up the UID and GID for the www-data user
fn get_www_data_uid_gid() -> Result<(u32, u32), Box<dyn std::error::Error>> {
    use std::process::Command;
    
    // Ensure www-data user exists first
    ensure_www_data_user()?;
    
    // Try to get UID for www-data
    let uid_output = Command::new("id")
        .args(&["-u", "www-data"])
        .output()?;
    
    if !uid_output.status.success() {
        return Err("www-data user not found after creation attempt".into());
    }
    
    let uid_str = String::from_utf8(uid_output.stdout)?;
    let uid = uid_str.trim().parse::<u32>()?;
    
    // Try to get GID for www-data
    let gid_output = Command::new("id")
        .args(&["-g", "www-data"])
        .output()?;
    
    if !gid_output.status.success() {
        return Err("www-data group not found".into());
    }
    
    let gid_str = String::from_utf8(gid_output.stdout)?;
    let gid = gid_str.trim().parse::<u32>()?;
    
    Ok((uid, gid))
}

/// Automatically detect the server's IP addresses from network interfaces
fn detect_server_ips() -> Result<Vec<IpAddr>, Box<dyn std::error::Error>> {
    use get_if_addrs::{get_if_addrs, IfAddr};
    
    let interfaces = get_if_addrs()?;
    let mut ip_addresses = Vec::new();
    
    for interface in interfaces {
        match interface.addr {
            IfAddr::V4(ipv4) => {
                ip_addresses.push(IpAddr::V4(ipv4.ip));
            }
            IfAddr::V6(ipv6) => {
                ip_addresses.push(IpAddr::V6(ipv6.ip));
            }
        }
    }
    
    println!("Detected {} IP addresses: {:?}", ip_addresses.len(), ip_addresses);
    Ok(ip_addresses)
}

/// Parse comma-separated IP addresses
fn parse_allowed_ips(ips_str: &str) -> Result<Vec<IpAddr>, Box<dyn std::error::Error>> {
    let mut ips = Vec::new();
    
    for ip_str in ips_str.split(',') {
        let ip_str = ip_str.trim();
        if ip_str.is_empty() {
            continue;
        }
        
        let ip: IpAddr = ip_str.parse()?;
        ips.push(ip);
    }
    
    Ok(ips)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 EasyPeas HTTPS Server starting - Debug version with enhanced ACME integration");
    let args = Args::parse();

    // Initialize logging
    if args.verbose {
        env_logger::Builder::new()
            .parse_filters("debug")
            .init();
    } else {
        env_logger::Builder::new()
            .parse_filters("info")
            .init();
    }

    // Create and run server
    let server = OnDemandHttpsServer::new(args)?;
    server.run()?;

    Ok(())
}
