use std::fs;
use std::path::Path;

fn main() {
    // Only generate extensions if the extensions feature is enabled
    if cfg!(feature = "extensions") {
        generate_extensions();
    }
}

fn generate_extensions() {
    let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
    let output_file = Path::new(&out_dir).join("generated_extensions.rs");
    
    let mut generated_code = String::new();
    
    // Add header
    generated_code.push_str("// Auto-generated extensions file\n");
    generated_code.push_str("// This file is generated by build.rs for the extensions feature\n\n");
    
    // Add simple math extension
    generated_code.push_str("// Math extension for processing #EXTEND:math(...) directives\n");
    generated_code.push_str("pub fn math_extend(_url: &str, args: &str) -> String {\n");
    generated_code.push_str("    // Parse arguments for math operations\n");
    generated_code.push_str("    let parts: Vec<&str> = args.split(',').map(|s| s.trim()).collect();\n");
    generated_code.push_str("    \n");
    generated_code.push_str("    match parts.as_slice() {\n");
    generated_code.push_str("        [\"add\", a, b] => {\n");
    generated_code.push_str("            if let (Ok(num_a), Ok(num_b)) = (a.parse::<f64>(), b.parse::<f64>()) {\n");
    generated_code.push_str("                let result = num_a + num_b;\n");
    generated_code.push_str("                format!(\"<span class=\\\"math-result\\\">{} + {} = {}</span>\", a, b, result)\n");
    generated_code.push_str("            } else {\n");
    generated_code.push_str("                format!(\"<span class=\\\"math-error\\\">Invalid numbers: {}, {}</span>\", a, b)\n");
    generated_code.push_str("            }\n");
    generated_code.push_str("        }\n");
    generated_code.push_str("        [\"multiply\", a, b] => {\n");
    generated_code.push_str("            if let (Ok(num_a), Ok(num_b)) = (a.parse::<f64>(), b.parse::<f64>()) {\n");
    generated_code.push_str("                let result = num_a * num_b;\n");
    generated_code.push_str("                format!(\"<span class=\\\"math-result\\\">{} Ã— {} = {}</span>\", a, b, result)\n");
    generated_code.push_str("            } else {\n");
    generated_code.push_str("                format!(\"<span class=\\\"math-error\\\">Invalid numbers: {}, {}</span>\", a, b)\n");
    generated_code.push_str("            }\n");
    generated_code.push_str("        }\n");
    generated_code.push_str("        [\"pi\"] => {\n");
    generated_code.push_str("            format!(\"<span class=\\\"math-constant\\\">Ï€ = 3.14159265359</span>\")\n");
    generated_code.push_str("        }\n");
    generated_code.push_str("        _ => {\n");
    generated_code.push_str("            format!(\"<span class=\\\"math-error\\\">Unknown math operation: {}</span>\", args)\n");
    generated_code.push_str("        }\n");
    generated_code.push_str("    }\n");
    generated_code.push_str("}\n\n");
    
    // Add ExtensionRegistry implementation
    generated_code.push_str("#[derive(Clone)]\n");
    generated_code.push_str("pub struct ExtensionRegistry {\n");
    generated_code.push_str("    // Extension registry state\n");
    generated_code.push_str("}\n\n");
    
    generated_code.push_str("impl ExtensionRegistry {\n");
    generated_code.push_str("    pub fn new() -> Self {\n");
    generated_code.push_str("        Self {\n");
    generated_code.push_str("            // Initialize extension registry\n");
    generated_code.push_str("        }\n");
    generated_code.push_str("    }\n\n");
    
    generated_code.push_str("    pub fn process_html(&self, html: &str, _url: &str) -> String {\n");
    generated_code.push_str("        let mut processed = html.to_string();\n");
    generated_code.push_str("        \n");
    generated_code.push_str("        // Process #EXTEND:math(...) directives\n");
    generated_code.push_str("        processed = self.process_math_extensions(&processed);\n");
    generated_code.push_str("        \n");
    generated_code.push_str("        processed\n");
    generated_code.push_str("    }\n\n");
    
    generated_code.push_str("    fn process_math_extensions(&self, html: &str) -> String {\n");
    generated_code.push_str("        use regex::Regex;\n");
    generated_code.push_str("        \n");
    generated_code.push_str("        let re = Regex::new(r\"#EXTEND:math\\(([^)]+)\\)\").unwrap();\n");
    generated_code.push_str("        \n");
    generated_code.push_str("        re.replace_all(html, |caps: &regex::Captures| {\n");
    generated_code.push_str("            let args = &caps[1];\n");
    generated_code.push_str("            math_extend(\"\", args)\n");
    generated_code.push_str("        }).to_string()\n");
    generated_code.push_str("    }\n\n");
    
    generated_code.push_str("    pub fn is_valid_admin_key(&self, key: &str) -> bool {\n");
    generated_code.push_str("        // Simple admin key validation\n");
    generated_code.push_str("        key.len() >= 8\n");
    generated_code.push_str("    }\n\n");
    
    generated_code.push_str("    pub async fn process_admin_request(\n");
    generated_code.push_str("        &self,\n");
    generated_code.push_str("        _path: &str,\n");
    generated_code.push_str("        _query: &str,\n");
    generated_code.push_str("        _body: &str,\n");
    generated_code.push_str("        _headers: &std::collections::HashMap<String, String>,\n");
    generated_code.push_str("    ) -> Result<String, Box<dyn std::error::Error>> {\n");
    generated_code.push_str("        // Process admin requests\n");
    generated_code.push_str("        Ok(r#\"{\"message\": \"Admin features available with extensions enabled\"}\"#.to_string())\n");
    generated_code.push_str("    }\n");
    generated_code.push_str("}\n");
    
    // Write the generated file
    fs::write(&output_file, generated_code).expect("Failed to write generated extensions file");
    
    println!("cargo:rerun-if-changed=../../extensions");
}
